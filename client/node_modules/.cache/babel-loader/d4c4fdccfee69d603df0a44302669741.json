{"ast":null,"code":"const Transport = require(\"../transport\");\nconst parseqs = require(\"parseqs\");\nconst parser = require(\"engine.io-parser\");\nconst yeast = require(\"yeast\");\nconst debug = require(\"debug\")(\"engine.io-client:polling\");\nclass Polling extends Transport {\n  /**\n   * Transport name.\n   */\n  get name() {\n    return \"polling\";\n  }\n\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @api private\n   */\n  doOpen() {\n    this.poll();\n  }\n\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} callback upon buffers are flushed and transport is paused\n   * @api private\n   */\n  pause(onPause) {\n    const self = this;\n    this.readyState = \"pausing\";\n    function pause() {\n      debug(\"paused\");\n      self.readyState = \"paused\";\n      onPause();\n    }\n    if (this.polling || !this.writable) {\n      let total = 0;\n      if (this.polling) {\n        debug(\"we are currently polling - waiting to pause\");\n        total++;\n        this.once(\"pollComplete\", function () {\n          debug(\"pre-pause polling complete\");\n          --total || pause();\n        });\n      }\n      if (!this.writable) {\n        debug(\"we are currently writing - waiting to pause\");\n        total++;\n        this.once(\"drain\", function () {\n          debug(\"pre-pause writing complete\");\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n\n  /**\n   * Starts polling cycle.\n   *\n   * @api public\n   */\n  poll() {\n    debug(\"polling\");\n    this.polling = true;\n    this.doPoll();\n    this.emit(\"poll\");\n  }\n\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @api private\n   */\n  onData(data) {\n    const self = this;\n    debug(\"polling got data %s\", data);\n    const callback = function (packet, index, total) {\n      // if its the first message we consider the transport open\n      if (\"opening\" === self.readyState && packet.type === \"open\") {\n        self.onOpen();\n      }\n\n      // if its a close packet, we close the ongoing requests\n      if (\"close\" === packet.type) {\n        self.onClose();\n        return false;\n      }\n\n      // otherwise bypass onData and handle the message\n      self.onPacket(packet);\n    };\n\n    // decode payload\n    parser.decodePayload(data, this.socket.binaryType).forEach(callback);\n\n    // if an event did not trigger closing\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this.polling = false;\n      this.emit(\"pollComplete\");\n      if (\"open\" === this.readyState) {\n        this.poll();\n      } else {\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\n      }\n    }\n  }\n\n  /**\n   * For polling, send a close packet.\n   *\n   * @api private\n   */\n  doClose() {\n    const self = this;\n    function close() {\n      debug(\"writing close packet\");\n      self.write([{\n        type: \"close\"\n      }]);\n    }\n    if (\"open\" === this.readyState) {\n      debug(\"transport open - closing\");\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      debug(\"transport not open - deferring close\");\n      this.once(\"open\", close);\n    }\n  }\n\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} data packets\n   * @param {Function} drain callback\n   * @api private\n   */\n  write(packets) {\n    this.writable = false;\n    parser.encodePayload(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emit(\"drain\");\n      });\n    });\n  }\n\n  /**\n   * Generates uri for connection.\n   *\n   * @api private\n   */\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\";\n\n    // cache busting is forced\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    }\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    }\n    query = parseqs.encode(query);\n\n    // avoid port if default for schema\n    if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    }\n\n    // prepend ? to query\n    if (query.length) {\n      query = \"?\" + query;\n    }\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n  }\n}\nmodule.exports = Polling;","map":{"version":3,"names":["Transport","require","parseqs","parser","yeast","debug","Polling","name","doOpen","poll","pause","onPause","self","readyState","polling","writable","total","once","doPoll","emit","onData","data","callback","packet","index","type","onOpen","onClose","onPacket","decodePayload","socket","binaryType","forEach","doClose","close","write","packets","encodePayload","doWrite","uri","query","schema","opts","secure","port","timestampRequests","timestampParam","supportsBinary","sid","b64","encode","Number","length","ipv6","hostname","indexOf","path","module","exports"],"sources":["E:/PFE/client/node_modules/engine.io-client/lib/transports/polling.js"],"sourcesContent":["const Transport = require(\"../transport\");\nconst parseqs = require(\"parseqs\");\nconst parser = require(\"engine.io-parser\");\nconst yeast = require(\"yeast\");\n\nconst debug = require(\"debug\")(\"engine.io-client:polling\");\n\nclass Polling extends Transport {\n  /**\n   * Transport name.\n   */\n  get name() {\n    return \"polling\";\n  }\n\n  /**\n   * Opens the socket (triggers polling). We write a PING message to determine\n   * when the transport is open.\n   *\n   * @api private\n   */\n  doOpen() {\n    this.poll();\n  }\n\n  /**\n   * Pauses polling.\n   *\n   * @param {Function} callback upon buffers are flushed and transport is paused\n   * @api private\n   */\n  pause(onPause) {\n    const self = this;\n\n    this.readyState = \"pausing\";\n\n    function pause() {\n      debug(\"paused\");\n      self.readyState = \"paused\";\n      onPause();\n    }\n\n    if (this.polling || !this.writable) {\n      let total = 0;\n\n      if (this.polling) {\n        debug(\"we are currently polling - waiting to pause\");\n        total++;\n        this.once(\"pollComplete\", function() {\n          debug(\"pre-pause polling complete\");\n          --total || pause();\n        });\n      }\n\n      if (!this.writable) {\n        debug(\"we are currently writing - waiting to pause\");\n        total++;\n        this.once(\"drain\", function() {\n          debug(\"pre-pause writing complete\");\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n\n  /**\n   * Starts polling cycle.\n   *\n   * @api public\n   */\n  poll() {\n    debug(\"polling\");\n    this.polling = true;\n    this.doPoll();\n    this.emit(\"poll\");\n  }\n\n  /**\n   * Overloads onData to detect payloads.\n   *\n   * @api private\n   */\n  onData(data) {\n    const self = this;\n    debug(\"polling got data %s\", data);\n    const callback = function(packet, index, total) {\n      // if its the first message we consider the transport open\n      if (\"opening\" === self.readyState && packet.type === \"open\") {\n        self.onOpen();\n      }\n\n      // if its a close packet, we close the ongoing requests\n      if (\"close\" === packet.type) {\n        self.onClose();\n        return false;\n      }\n\n      // otherwise bypass onData and handle the message\n      self.onPacket(packet);\n    };\n\n    // decode payload\n    parser.decodePayload(data, this.socket.binaryType).forEach(callback);\n\n    // if an event did not trigger closing\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this.polling = false;\n      this.emit(\"pollComplete\");\n\n      if (\"open\" === this.readyState) {\n        this.poll();\n      } else {\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\n      }\n    }\n  }\n\n  /**\n   * For polling, send a close packet.\n   *\n   * @api private\n   */\n  doClose() {\n    const self = this;\n\n    function close() {\n      debug(\"writing close packet\");\n      self.write([{ type: \"close\" }]);\n    }\n\n    if (\"open\" === this.readyState) {\n      debug(\"transport open - closing\");\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      debug(\"transport not open - deferring close\");\n      this.once(\"open\", close);\n    }\n  }\n\n  /**\n   * Writes a packets payload.\n   *\n   * @param {Array} data packets\n   * @param {Function} drain callback\n   * @api private\n   */\n  write(packets) {\n    this.writable = false;\n\n    parser.encodePayload(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emit(\"drain\");\n      });\n    });\n  }\n\n  /**\n   * Generates uri for connection.\n   *\n   * @api private\n   */\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\";\n\n    // cache busting is forced\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    }\n\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    }\n\n    query = parseqs.encode(query);\n\n    // avoid port if default for schema\n    if (\n      this.opts.port &&\n      ((\"https\" === schema && Number(this.opts.port) !== 443) ||\n        (\"http\" === schema && Number(this.opts.port) !== 80))\n    ) {\n      port = \":\" + this.opts.port;\n    }\n\n    // prepend ? to query\n    if (query.length) {\n      query = \"?\" + query;\n    }\n\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return (\n      schema +\n      \"://\" +\n      (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\n      port +\n      this.opts.path +\n      query\n    );\n  }\n}\n\nmodule.exports = Polling;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}